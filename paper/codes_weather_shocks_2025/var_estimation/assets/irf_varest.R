# This set of functions is the replication of the code found in the function
# irf.varestpackage vars to compute the IRFs.
# But we correct it so that it works with restricted vars.

#' irf_varest
irf_varest <- function(x, 
                       impulse = NULL, 
                       response = NULL, 
                       n.ahead = 10, 
                       ortho = TRUE, 
                       cumulative = FALSE, 
                       boot = TRUE, 
                       ci = 0.95, 
                       runs = 100, 
                       seed = NULL, 
                       restrict = NULL, ...) {
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  y.names <- colnames(x$y)
  if (is.null(impulse)) {
    impulse <- y.names
  } else {
    impulse <- as.vector(as.character(impulse))
    if(any(!(impulse %in% y.names))) {
      stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
    }
    impulse <- subset(y.names, subset = y.names %in% impulse)
  }
  if (is.null(response)) {
    response <- y.names
  } else {
    response <- as.vector(as.character(response))
    if(any(!(response %in% y.names))){
      stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
    }
    response <- subset(y.names, subset = y.names %in% response)
  }
  ## Getting the irf
  irs <- irf_internal(
    x = x, 
    impulse = impulse, 
    response = response, 
    y.names = y.names, 
    n.ahead = n.ahead, 
    ortho = ortho, 
    cumulative = cumulative
  )
  ## Bootstrapping
  Lower <- NULL
  Upper <- NULL
  std_err <- NULL
  if (boot) {
    ci <- as.numeric(ci)
    if((ci <= 0)|(ci >= 1)){
      stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
    }
    ci <- 1 - ci
    BOOT <- boot_internal(x = x, n.ahead = n.ahead, runs = runs, ortho = ortho, cumulative = cumulative, impulse = impulse, response = response, ci = ci, seed = seed, y.names = y.names, restrict = restrict)
    Lower <- BOOT$Lower
    Upper <- BOOT$Upper
    std_err <- BOOT$sd
  }
  result <- list(
    irf = irs, 
    Lower = Lower, 
    Upper = Upper, 
    sd = std_err, 
    response = response, 
    impulse = impulse, 
    ortho = ortho, 
    cumulative = cumulative, 
    runs = runs, ci = ci, 
    boot = boot, 
    model = class(x)
  )
  class(result) <- "varirf"
  
  return(result)
}


#' irf (internal)
irf_internal <- function(x, 
                         impulse, 
                         response, 
                         y.names, 
                         n.ahead, 
                         ortho, 
                         cumulative) {
  if ((class(x) == "varest") || (class(x) == "vec2var")) {
    if(ortho){
      irf <- Psi(x, nstep = n.ahead)
    } else {
      irf <- Phi(x, nstep = n.ahead)
    }
  } else if ((class(x) == "svarest") || (class(x) == "svecest")) {
    irf <- Phi(x, nstep = n.ahead)
  }
  dimnames(irf) <- list(y.names, y.names, NULL)
  idx <- length(impulse)
  irs <- list()
  for (i in 1 : idx) {
    irs[[i]] <- matrix(
      t(irf[response , impulse[i], 1 : (n.ahead + 1)]),
      nrow = n.ahead+1
    )
    colnames(irs[[i]]) <- response
    if (cumulative) {
      if(length(response) > 1) irs[[i]] <- apply(irs[[i]], 2, cumsum)
      if(length(response) == 1){
        tmp <- matrix(cumsum(irs[[1]]))
        colnames(tmp) <- response
        irs[[1]] <- tmp
      }
    }
  }
  names(irs) <- impulse
  result <- irs
  
  return(result)    
}


#' boot_internal
#' Bootstrapping IRF for VAR and SVAR
#' 
boot_internal <- function(x, 
                          n.ahead, 
                          runs, 
                          ortho, 
                          cumulative, 
                          impulse, 
                          response, 
                          ci, 
                          seed, 
                          y.names, 
                          restrict = NULL) {
  if (!(is.null(seed))) set.seed(abs(as.integer(seed)))
  if (class(x) == "varest") {
    VAR <- eval.parent(x)
  } else if (class(x) == "svarest") {
    VAR <- eval.parent(x$var)
  } else {
    stop("Bootstrap not implemented for this class.\n")
  }
  p <- VAR$p
  K <- VAR$K
  obs <- VAR$obs
  total <- VAR$totobs
  type <- VAR$type
  B <- Bcoef(VAR)
  BOOT <- vector("list", runs)
  ysampled <- matrix(0, nrow = total, ncol = K)
  colnames(ysampled) <- colnames(VAR$y)
  Zdet <- NULL
  if (ncol(VAR$datamat) > (K * (p+1))) {
    Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
  }
  resorig <- scale(resid(VAR), scale = FALSE)
  B <- Bcoef(VAR)
  for (i in 1:runs) {
    booted <- sample(c(1 : obs), replace=TRUE)
    resid <- resorig[booted, ]
    lasty <- c(t(VAR$y[p : 1, ]))
    ysampled[c(1 : p), ] <- VAR$y[c(1 : p), ]
    for(j in 1 : obs){
      lasty <- lasty[1 : (K * p)]
      Z <- c(lasty, Zdet[j, ])
      ysampled[j + p, ] <- B %*% Z + resid[j, ]
      lasty <- c(ysampled[j + p, ], lasty) 
    }
    
    varboot <- update(VAR, y = ysampled)
    if (!is.null(restrict)) 
      varboot <- restrict(varboot, method = "man", resmat = restrict)
    if (class(x) == "svarest") {
      varboot <- update(x, x = varboot)
    }
    BOOT[[i]] <- irf_internal(
      x = varboot, 
      n.ahead = n.ahead, 
      ortho = ortho, 
      cumulative = cumulative, 
      impulse = impulse, 
      response = response, 
      y.names = y.names
    )
  }
  lower <- ci / 2
  upper <- 1 - ci / 2
  mat.l <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  mat.u <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  mat.sd <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  Lower <- list()
  Upper <- list()
  std_err <- list()
  idx1 <- length(impulse)
  idx2 <- length(response)
  idx3 <- n.ahead + 1
  temp <- rep(NA, runs)
  for (j in 1 : idx1) {
    for (m in 1 : idx2) {
      for (l in 1 : idx3) {
        for (i in 1 : runs) {
          if (idx2 > 1) {
            temp[i] <- BOOT[[i]][[j]][l, m]
          } else {
            temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
          }
        }
        mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
        mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
        mat.sd[l, m] <- sd(temp, na.rm = TRUE)
      }
    }
    colnames(mat.l) <- response
    colnames(mat.u) <- response
    colnames(mat.sd) <- response
    Lower[[j]] <- mat.l
    Upper[[j]] <- mat.u
    std_err[[j]] <- mat.sd
  }
  names(Lower) <- impulse
  names(Upper) <- impulse
  names(std_err) <- impulse
  result <- list(Lower = Lower, Upper = Upper, sd = std_err)
  
  return(result)
}


